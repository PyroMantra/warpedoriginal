from werkzeug.security import generate_password_hash, check_password_hash
from datetime import datetime
from flask import Flask, render_template, redirect, url_for, session, request
from functools import wraps
import pandas as pd
import os
import re
import sqlite3
import random
from collections import defaultdict
from authlib.integrations.flask_client import OAuth

app = Flask(__name__)
app.secret_key = 'supersecretkey'

# --- Auth DB ---
DB_PATH = os.path.join("data", "auth.db")
os.makedirs("data", exist_ok=True)

def get_db():
    conn = sqlite3.connect(DB_PATH)
    conn.row_factory = sqlite3.Row
    return conn

def init_auth_db():
    conn = get_db()
    cur = conn.cursor()
    cur.execute(
        '''
        CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            email TEXT UNIQUE,
            username TEXT UNIQUE,
            password_hash TEXT,
            google_id TEXT,
            created_at TEXT NOT NULL
        )
        '''
    )
    conn.commit()
    conn.close()

init_auth_db()

# Google OAuth configuration via OpenID Discovery
app.config['GOOGLE_CLIENT_ID'] = os.getenv('GOOGLE_CLIENT_ID', '')
app.config['GOOGLE_CLIENT_SECRET'] = os.getenv('GOOGLE_CLIENT_SECRET', '')
oauth = OAuth(app)
google = oauth.register(
    name='google',
    client_id=app.config['GOOGLE_CLIENT_ID'],
    client_secret=app.config['GOOGLE_CLIENT_SECRET'],
    server_metadata_url='https://accounts.google.com/.well-known/openid-configuration',
    client_kwargs={'scope': 'openid email profile'}
)


USERS = {
    'admin': 'adminpass',
    'player1': 'playerpass'
}

EXCEL_PATH = os.path.join("data", "Layer List (7).xlsx")
sheets = pd.read_excel(EXCEL_PATH, sheet_name=None)

# Remove sheets not meant for generic viewing
sheets = {k: v for k, v in sheets.items() if k not in ["Classes", "Races", "Abilities"]}
SHEET_NAMES = list(sheets.keys())
generator_sheets = [name for name in SHEET_NAMES if "Generator" in name]

def login_required(f):
    @wraps(f)
    def wrapper(*args, **kwargs):
        if not session.get("user_id"):
            return redirect(url_for("login"))
        return f(*args, **kwargs)
    return wrapper

@app.route("/")
@login_required
def home():
    user = session.get("user")
    data_buttons = [
    {"label": "The Informatorium", "endpoint": "view_sheet", "arg": "The Informatorium"},
    {"label": "Races", "endpoint": "races_table"},
    {"label": "Classes", "endpoint": "classes_view"},

    {"label": "Scaling", "endpoint": "view_notion_db", "arg": "Scaling"},
    {"label": "Damage Calculation", "endpoint": "view_notion_db", "arg": "Damage Calculation"},
    {"label": "Roll Info", "endpoint": "view_sheet", "arg": "Roll Information"},
    {"label": "Skills", "endpoint": "view_sheet", "arg": "Skills"},
    {"label": "Zones", "endpoint": "view_sheet", "arg": "Zones"},
    {"label": "Gear Set", "endpoint": "view_sheet", "arg": "Gear Set"},
    {"label": "Crafting", "endpoint": "view_sheet", "arg": "Crafting"},
    {"label": "Resonance", "endpoint": "view_sheet", "arg": "RESONANCE"},
    {"label": "Mastery", "endpoint": "view_sheet", "arg": "MASTERY"},
    {"label": "Legacy", "endpoint": "view_sheet", "arg": "LEGACY"},
    {"label": "Clarifications", "endpoint": "view_sheet", "arg": "Clarifications & Mechanics"},
    {"label": "Items", "endpoint": "view_sheet", "arg": "Items"},
    {"label": "Gear", "endpoint": "view_sheet", "arg": "Gear"}
]

    return render_template("dashboard.html", user=user, data_buttons=data_buttons, generators=generator_sheets)


@app.route("/view/<sheet>")
@login_required
def view_sheet(sheet):
    if sheet not in sheets:
        return f"Sheet '{sheet}' not found.", 404
    df = sheets[sheet].fillna("").astype(str)
    headers = df.columns.tolist()
    rows = df.values.tolist()
    return render_template("view_sheet.html", sheet=sheet, headers=headers, rows=rows)

@app.route("/generate/<sheet>")
@login_required
def generate(sheet):
    if sheet not in generator_sheets:
        return f"'{sheet}' is not a generator sheet.", 403
    df = sheets[sheet].dropna(how="all")
    if df.empty:
        return "No data to generate."
    random_row = df.sample(n=1).to_dict(orient="records")[0]
    return render_template("generator.html", sheet=sheet, row=random_row)

@app.route("/potion-generator")
@login_required
def potion_generator():
    potion_df = pd.read_excel("static/Book 10.xlsx", sheet_name="Sheet1")
    potion_map = {
        str(row["Concat"]).strip(): row["POTION"]
        for _, row in potion_df.iterrows()
        if pd.notna(row["Concat"]) and pd.notna(row["POTION"])
    }
    selected = [request.args.get(f"ingredient{i}", "Nothing") for i in range(1, 11)]
    selected = [s for s in selected if s]
    combos = set()
    for i in range(len(selected)):
        for j in range(i + 1, len(selected)):
            a, b = selected[i].strip(), selected[j].strip()
            combo = f"{a} + {b}" if a <= b else f"{b} + {a}"
            combos.add(combo)
    matches = sorted([
        {"mix": combo, "result": potion_map[combo]}
        for combo in combos if combo in potion_map
    ], key=lambda x: x["mix"].lower())
    ingredients = sorted({part.strip() for combo in potion_map for part in combo.split('+')} | {"Nothing"})
    return render_template(
        "potion_generator.html",
        ingredients=ingredients,
        matches=matches,
        selected_ings_map={f"ingredient{i+1}": selected[i] if i < len(selected) else "" for i in range(10)}
    )

@app.route("/races-table")
@login_required
def races_table():
    path = "static/notion/Races Main 207ec6426bd5807b925cddd6c35d0f14_all.csv"
    df = pd.read_csv(path).fillna("")
    df.columns = df.columns.str.strip()
    if "RACE" in df.columns and "SUBTYPE" in df.columns:
        df["RACE"] = df["RACE"].apply(lambda x: x.split(' (')[0] if isinstance(x, str) else x)
        cols = df.columns.tolist()
        if cols.index("RACE") > cols.index("SUBTYPE"):
            race_idx, sub_idx = cols.index("RACE"), cols.index("SUBTYPE")
            cols[race_idx], cols[sub_idx] = cols[sub_idx], cols[race_idx]
            df = df[cols]
    stamina_col = next((col for col in df.columns if col.lower() == "stamina"), None)
    if stamina_col:
        df[stamina_col] = df[stamina_col].apply(lambda x: round(float(x)) if str(x).replace('.', '', 1).isdigit() else x)
    for col in [c for c in df.columns if "resistance" in c.lower()]:
        df[col] = df[col].apply(lambda x: f"{float(x)*100:.0f}%" if str(x).replace('.', '', 1).isdigit() else x)
    return render_template("races_table.html", headers=df.columns.tolist(), rows=df.values.tolist())

@app.route("/races-gallery")
@login_required
def races_gallery():
    path = "static/notion/Races Main 207ec6426bd5807b925cddd6c35d0f14_all.csv"
    df = pd.read_csv(path).fillna("")
    STAT_LABELS = [
        "Health", "Mana", "Conditions", "Defense", "Dispersion", "Strength", "Dexterity",
        "Power", "Stamina", "Fortitude", "Light Resistance", "Dark Resistance",
        "Fire Resistance", "Frost Resistance", "Wind Resistance", "Earth Resistance",
        "Lightning Resistance", "Bleed Resistance", "Poison Resistance"
    ]
    tree = {}
    for _, row in df.iterrows():
        kin, race, subrace = row.get("KIN", "").strip(), row.get("RACE", "").split(' (')[0].strip(), row.get("SUBTYPE", "").strip()
        if not (kin and race and subrace):
            continue
        stats = [row.get(col, "") for col in df.columns if col not in ("KIN", "RACE", "SUBTYPE")]
        resistance_start = STAT_LABELS.index("Light Resistance")
        stats[8] = str(round(float(stats[8]))) if str(stats[8]).replace('.', '', 1).isdigit() else stats[8]
        resistances = [
            f"{float(val)*100:.0f}%" if str(val).replace('.', '', 1).isdigit() else val
            for val in stats[resistance_start:resistance_start+9]
        ]
        full_stats = stats[:resistance_start] + resistances
        labeled_stats = list(zip(STAT_LABELS, full_stats[:len(STAT_LABELS)]))
        tree.setdefault(kin, {}).setdefault(race, []).append({"subrace": subrace, "stats": labeled_stats})
    return render_template("races_gallery.html", tree=tree)

@app.route("/notion-db")
@login_required
def notion_db_index():
    base_path = "static/notion"
    csv_files = [f for f in os.listdir(base_path) if f.endswith(".csv")]
    databases = [f.replace(".csv", "") for f in csv_files]
    return render_template("notion_index.html", databases=databases)

@app.route("/notion-db/<db>")
@login_required
def view_notion_db(db):
    path = f"static/notion/{db}.csv"
    if not os.path.exists(path):
        return f"{db} database not found.", 404
    df = pd.read_csv(path).fillna("N/A")
    return render_template("notion_table.html", db=db, headers=df.columns.tolist(), rows=df.values.tolist())

@app.route("/classes-view")
@login_required
def classes_view():
    path = os.path.join("static", "Data", "Normalized_Abilities.xlsx")
    
    table_df = pd.read_excel(path, sheet_name="Table").fillna("")
    data_df = pd.read_excel(path, sheet_name="Data").fillna("")
    affinity_df = pd.read_excel(path, sheet_name="Affinities S").fillna("")
    class_df = pd.read_excel(path, sheet_name="Classes S").fillna("")

    headers = table_df.columns.tolist()
    rows = table_df.values.tolist()

    # Organize ability data by Affinity and Type
    from collections import defaultdict
    ability_data = defaultdict(lambda: defaultdict(list))
    for _, row in data_df.iterrows():
        aff = row.get("Affinity", "").strip()
        typ = row.get("Type", "").strip()
        if not aff or not typ:
            continue
        ability_data[aff][typ].append({
            "Rank I": row.get("Rank I", "N/A") or "N/A",
            "Rank II": row.get("Rank II", "N/A") if typ != "Innate" else "N/A",
            "Rank III": row.get("Rank III", "N/A") if typ != "Innate" else "N/A",
        })

    # Normalize columns
    affinity_df.columns = affinity_df.columns.str.strip().str.upper()
    class_df.columns = class_df.columns.str.strip()

    affinity_info = {
        row["AFFINITY"]: {
            "difficulty": row.get("DIFFICULTY", "Unknown"),
            "description": row.get("DESCRIPTION", "")
        }
        for _, row in affinity_df.iterrows()
        if pd.notna(row.get("AFFINITY"))
    }

    class_info = {
    row["Class"]: {
        "bonus": row["Starting Bonus:"],
        "weapon": row["Starting Weapon:"]
    }
    for _, row in class_df.iterrows()
}




    return render_template(
        "classes_view.html",
        headers=headers,
        rows=rows,
        ability_data=ability_data,
        affinity_info=affinity_info,
        class_info=class_info
    )

@app.route("/login/google", endpoint="login_google")
def google_login_start():
    redirect_uri = url_for("auth_google_callback", _external=True)
    return google.authorize_redirect(redirect_uri)

@app.route("/auth/google/callback", endpoint="auth_google_callback")
def google_login_callback():
    token = google.authorize_access_token()
    resp = google.get("https://openidconnect.googleapis.com/v1/userinfo")
    info = resp.json()

    email = (info.get("email") or "").lower()
    sub = info.get("sub")

    if not email or not sub:
        return redirect(url_for("login"))

    conn = get_db()
    cur = conn.cursor()
    cur.execute("SELECT * FROM users WHERE email = ?", (email,))
    u = cur.fetchone()

    if u:
        if not u["google_id"]:
            cur.execute("UPDATE users SET google_id = ? WHERE id = ?", (sub, u["id"]))
            conn.commit()
        user_id = u["id"]
        username = u["username"]
    else:
        cur.execute(
            "INSERT INTO users (email, google_id, created_at) VALUES (?, ?, ?)",
            (email, sub, datetime.utcnow().isoformat())
        )
        conn.commit()
        user_id = cur.lastrowid
        username = None

    conn.close()

    session["user_id"] = user_id
    session["email"] = email
    session["username"] = username

    if not username:
        return redirect(url_for("pick_username"))
    return redirect(url_for("home"))

@app.route("/whoami")
def whoami():
    return f"logged in as: {session.get('user')!r}"

@app.route("/__routes__")
def list_routes():
    lines = []
    for rule in app.url_map.iter_rules():
        lines.append(f"{rule.endpoint}: {rule}")
    return "<br>".join(sorted(lines))

@app.route("/ping")
def ping():
    return "pong"


@app.route("/register", methods=["GET", "POST"], endpoint="register")
def register():
    if session.get("user_id"):
        return redirect(url_for("home"))

    if request.method == "POST":
        email = (request.form.get("email") or "").strip().lower()
        username = (request.form.get("username") or "").strip()
        password = request.form.get("password") or ""

        if not email or not username or not password:
            return render_template("register.html", error="Email, username and password are required.")

        conn = get_db()
        cur = conn.cursor()
        cur.execute("SELECT 1 FROM users WHERE email = ? OR username = ?", (email, username))
        exists = cur.fetchone()
        if exists:
            conn.close()
            return render_template("register.html", error="Email or username already exists.")

        pw_hash = generate_password_hash(password)

        cur.execute(
            "INSERT INTO users (email, username, password_hash, created_at) VALUES (?, ?, ?, ?)",
            (email, username, pw_hash, datetime.utcnow().isoformat()),
        )
        conn.commit()
        user_id = cur.lastrowid
        conn.close()

        session["user_id"] = user_id
        session["email"] = email
        session["username"] = username

        return redirect(url_for("home"))

    return render_template("register.html")

@app.route("/login", methods=["GET","POST"]) 
def login():
    if session.get("user_id"): return redirect(url_for("home"))
#     except Exception as e:
#         # Fail safe: send back to login with error
#         return redirect(url_for("login", error="google_auth_failed"))
    if request.method == "POST":
        email = request.form.get("email", "").strip().lower()
        password = request.form.get("password", "")
        conn = get_db()
        cur = conn.cursor()
        cur.execute("SELECT * FROM users WHERE email = ?", (email,))
        u = cur.fetchone()
        conn.close()
        if u and u["password_hash"] and check_password_hash(u["password_hash"], password):
            session["user_id"] = u["id"]
            session["email"] = u["email"]
            session["username"] = u["username"]
            return redirect(url_for("home"))
#     except Exception as e:
#         # Fail safe: send back to login with error
#         return redirect(url_for("login", error="google_auth_failed"))
#         return render_template("login.html", error="Invalid email or password.")
    return render_template("login.html")

@app.route("/pick-username", methods=["GET", "POST"])
@login_required
def pick_username():
    # If already has one, go home
    if session.get("username"):
        return redirect(url_for("home"))
#     except Exception as e:
#         # Fail safe: send back to login with error
#         return redirect(url_for("login", error="google_auth_failed"))
    if request.method == "POST":
        username = request.form.get("username", "").strip()
        if not re.match(r"^[A-Za-z0-9_]{3,20}$", username):
            return render_template("pick_username.html", error="Username must be 3-20 characters (letters, numbers, underscore).")
        conn = get_db()
        cur = conn.cursor()
        # Ensure unique
        cur.execute("SELECT 1 FROM users WHERE username = ?", (username,))
        exists = cur.fetchone()
        if exists:
            conn.close()
            return render_template("pick_username.html", error="That username is taken, try another.")
        cur.execute("UPDATE users SET username = ? WHERE id = ?", (username, session["user_id"]))
        conn.commit()
        conn.close()
        session["username"] = username
        return redirect(url_for("home"))
#     except Exception as e:
#         # Fail safe: send back to login with error
#         return redirect(url_for("login", error="google_auth_failed"))
    return render_template("pick_username.html")


@app.route("/logout")
def logout():
    session.clear()
    return redirect(url_for("login"))

@app.context_processor
def inject_current_user_display():
    # Compute a friendly display name once, expose as multiple aliases
    name = session.get('username')
    if not name:
        email = session.get('email')
        if email:
            name = email.split('@')[0]
    name = name or "Adventurer"
    return {
        "current_user_name": name,   # recommended in templates
        "username": name,            # legacy templates using {{ username }}
        "display_name": name,        # optional alias
    }

@app.before_request
def hydrate_username_in_session():
    try:
        if session.get("user_id") and not session.get("username"):
            conn = get_db()
            cur = conn.cursor()
            cur.execute("SELECT username, email FROM users WHERE id = ?", (session["user_id"],))
            u = cur.fetchone()
            conn.close()
            if u:
                if u.get("username"):
                    session["username"] = u["username"]
                elif u.get("email") and not session.get("email"):
                    session["email"] = u["email"]
    except Exception:
        # Never block a request on a best-effort hydration
        pass


if __name__ == "__main__":
    print("ATP DEBUG: starting server")
    print("--- ROUTES ---")
    for r in app.url_map.iter_rules():
        print(f"{r.endpoint}: {r}")
    print("--------------")

    app.run(host="127.0.0.1", port=5000, debug=True)
